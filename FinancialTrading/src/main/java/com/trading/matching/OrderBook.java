package com.trading.matching;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import com.trading.order.Order;
import com.trading.order.OrderSide;
import com.trading.order.OrderType;
import com.trading.matching.dto.MatchResult;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Slf4j
@Getter
public class OrderBook {
    
    private final String symbol;
    \n    // Buy orders sorted by price DESC, then by timestamp ASC\n    private final NavigableMap<BigDecimal, TreeSet<Order>> buyOrders = \n            new ConcurrentSkipListMap<>(Collections.reverseOrder());\n    \n    // Sell orders sorted by price ASC, then by timestamp ASC\n    private final NavigableMap<BigDecimal, TreeSet<Order>> sellOrders = \n            new ConcurrentSkipListMap<>();\n    \n    // Quick lookup by order ID\n    private final Map<String, Order> orderIndex = new ConcurrentHashMap<>();\n    \n    public OrderBook(String symbol) {\n        this.symbol = symbol;\n    }\n    \n    public synchronized void addOrder(Order order) {\n        if (order.getType() == OrderType.MARKET) {\n            // Market orders are executed immediately, not added to book\n            return;\n        }\n        \n        NavigableMap<BigDecimal, TreeSet<Order>> orders = \n                order.getSide() == OrderSide.BUY ? buyOrders : sellOrders;\n        \n        orders.computeIfAbsent(order.getPrice(), k -> \n                new TreeSet<>(Comparator.comparing(Order::getCreatedAt)))\n                .add(order);\n        \n        orderIndex.put(order.getOrderId(), order);\n        \n        log.debug(\"Added {} order: {} at price {} to order book for {}\", \n                order.getSide(), order.getOrderId(), order.getPrice(), symbol);\n    }\n    \n    public synchronized void removeOrder(String orderId) {\n        Order order = orderIndex.remove(orderId);\n        if (order == null) {\n            return;\n        }\n        \n        NavigableMap<BigDecimal, TreeSet<Order>> orders = \n                order.getSide() == OrderSide.BUY ? buyOrders : sellOrders;\n        \n        TreeSet<Order> priceLevel = orders.get(order.getPrice());\n        if (priceLevel != null) {\n            priceLevel.remove(order);\n            if (priceLevel.isEmpty()) {\n                orders.remove(order.getPrice());\n            }\n        }\n        \n        log.debug(\"Removed order: {} from order book for {}\", orderId, symbol);\n    }\n    \n    public synchronized void updateOrder(Order updatedOrder) {\n        removeOrder(updatedOrder.getOrderId());\n        addOrder(updatedOrder);\n    }\n    \n    public synchronized MatchResult matchOrders() {\n        if (buyOrders.isEmpty() || sellOrders.isEmpty()) {\n            return null;\n        }\n        \n        BigDecimal bestBuyPrice = buyOrders.firstKey();\n        BigDecimal bestSellPrice = sellOrders.firstKey();\n        \n        // Check if orders can be matched (buy price >= sell price)\n        if (bestBuyPrice.compareTo(bestSellPrice) < 0) {\n            return null;\n        }\n        \n        Order buyOrder = buyOrders.get(bestBuyPrice).first();\n        Order sellOrder = sellOrders.get(bestSellPrice).first();\n        \n        // Determine trade price (price of the order that was placed first)\n        BigDecimal tradePrice = buyOrder.getCreatedAt().isBefore(sellOrder.getCreatedAt()) ?\n                buyOrder.getPrice() : sellOrder.getPrice();\n        \n        // Determine trade quantity\n        BigDecimal buyRemainingQty = buyOrder.getRemainingQuantity();\n        BigDecimal sellRemainingQty = sellOrder.getRemainingQuantity();\n        BigDecimal tradeQuantity = buyRemainingQty.min(sellRemainingQty);\n        \n        // Update order quantities\n        buyOrder.setFilledQuantity(buyOrder.getFilledQuantity().add(tradeQuantity));\n        sellOrder.setFilledQuantity(sellOrder.getFilledQuantity().add(tradeQuantity));\n        \n        // Remove filled orders from book\n        if (buyOrder.isFullyFilled()) {\n            removeOrderFromPriceLevel(buyOrders, bestBuyPrice, buyOrder);\n        }\n        \n        if (sellOrder.isFullyFilled()) {\n            removeOrderFromPriceLevel(sellOrders, bestSellPrice, sellOrder);\n        }\n        \n        return MatchResult.builder()\n                .symbol(symbol)\n                .buyOrder(buyOrder)\n                .sellOrder(sellOrder)\n                .quantity(tradeQuantity)\n                .price(tradePrice)\n                .matched(true)\n                .build();\n    }\n    \n    public List<Order> getOrders(OrderSide side, int levels) {\n        NavigableMap<BigDecimal, TreeSet<Order>> orders = \n                side == OrderSide.BUY ? buyOrders : sellOrders;\n        \n        return orders.entrySet().stream()\n                .limit(levels)\n                .flatMap(entry -> entry.getValue().stream())\n                .collect(Collectors.toList());\n    }\n    \n    public BigDecimal getBestBid() {\n        return buyOrders.isEmpty() ? BigDecimal.ZERO : buyOrders.firstKey();\n    }\n    \n    public BigDecimal getBestAsk() {\n        return sellOrders.isEmpty() ? BigDecimal.ZERO : sellOrders.firstKey();\n    }\n    \n    public BigDecimal getSpread() {\n        if (buyOrders.isEmpty() || sellOrders.isEmpty()) {\n            return BigDecimal.ZERO;\n        }\n        return getBestAsk().subtract(getBestBid());\n    }\n    \n    public int getOrderCount(OrderSide side) {\n        NavigableMap<BigDecimal, TreeSet<Order>> orders = \n                side == OrderSide.BUY ? buyOrders : sellOrders;\n        return orders.values().stream().mapToInt(TreeSet::size).sum();\n    }\n    \n    public BigDecimal getTotalVolume(OrderSide side) {\n        NavigableMap<BigDecimal, TreeSet<Order>> orders = \n                side == OrderSide.BUY ? buyOrders : sellOrders;\n        \n        return orders.values().stream()\n                .flatMap(TreeSet::stream)\n                .map(Order::getRemainingQuantity)\n                .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n    \n    private void removeOrderFromPriceLevel(NavigableMap<BigDecimal, TreeSet<Order>> orders,\n                                         BigDecimal price, Order order) {\n        TreeSet<Order> priceLevel = orders.get(price);\n        if (priceLevel != null) {\n            priceLevel.remove(order);\n            if (priceLevel.isEmpty()) {\n                orders.remove(price);\n            }\n        }\n        orderIndex.remove(order.getOrderId());\n    }\n}