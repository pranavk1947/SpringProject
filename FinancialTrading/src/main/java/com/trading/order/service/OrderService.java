package com.trading.order.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import com.trading.order.Order;
import com.trading.order.OrderStatus;
import com.trading.order.dto.CreateOrderRequest;
import com.trading.order.dto.OrderResponse;
import com.trading.order.dto.UpdateOrderRequest;
import com.trading.order.repository.OrderRepository;
import com.trading.order.mapper.OrderMapper;
import com.trading.matching.MatchingEngineService;
import com.trading.common.exception.OrderNotFoundException;
import com.trading.common.exception.InvalidOrderStateException;
import com.trading.common.service.IdGeneratorService;
import com.trading.common.service.ValidationService;

import java.time.LocalDateTime;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final MatchingEngineService matchingEngineService;
    private final IdGeneratorService idGeneratorService;
    private final ValidationService validationService;
    private final OrderEventPublisher orderEventPublisher;
    
    @Transactional
    public Mono<OrderResponse> createOrder(String userId, CreateOrderRequest request) {\n        log.debug(\"Creating order for user: {}, symbol: {}\", userId, request.getSymbol());\n        \n        return validationService.validateOrderRequest(userId, request)\n                .then(Mono.fromCallable(() -> buildOrderFromRequest(userId, request)))\n                .flatMap(this::validateAndSaveOrder)\n                .flatMap(this::publishOrderToMatchingEngine)\n                .map(orderMapper::toResponse)\n                .doOnSuccess(response -> log.info(\"Order created successfully: {}\", response.getOrderId()))\n                .doOnError(error -> log.error(\"Failed to create order for user: {}\", userId, error));\n    }\n    \n    @Transactional\n    public Mono<OrderResponse> updateOrder(String userId, String orderId, UpdateOrderRequest request) {\n        log.debug(\"Updating order: {} for user: {}\", orderId, userId);\n        \n        return findUserOrder(userId, orderId)\n                .flatMap(order -> validateOrderForUpdate(order, request))\n                .flatMap(order -> updateOrderFields(order, request))\n                .flatMap(orderRepository::save)\n                .flatMap(this::publishOrderUpdateToMatchingEngine)\n                .map(orderMapper::toResponse)\n                .doOnSuccess(response -> log.info(\"Order updated successfully: {}\", orderId))\n                .doOnError(error -> log.error(\"Failed to update order: {}\", orderId, error));\n    }\n    \n    @Transactional\n    public Mono<OrderResponse> cancelOrder(String userId, String orderId) {\n        log.debug(\"Cancelling order: {} for user: {}\", orderId, userId);\n        \n        return findUserOrder(userId, orderId)\n                .flatMap(this::validateOrderForCancellation)\n                .doOnNext(Order::cancel)\n                .flatMap(orderRepository::save)\n                .flatMap(this::publishOrderCancellationToMatchingEngine)\n                .map(orderMapper::toResponse)\n                .doOnSuccess(response -> log.info(\"Order cancelled successfully: {}\", orderId))\n                .doOnError(error -> log.error(\"Failed to cancel order: {}\", orderId, error));\n    }\n    \n    public Mono<OrderResponse> getOrder(String userId, String orderId) {\n        return findUserOrder(userId, orderId)\n                .map(orderMapper::toResponse);\n    }\n    \n    public Flux<OrderResponse> getUserOrders(String userId, int page, int size) {\n        return orderRepository.findByUserIdOrderByCreatedAtDesc(userId)\n                .skip((long) page * size)\n                .take(size)\n                .map(orderMapper::toResponse)\n                .subscribeOn(Schedulers.boundedElastic());\n    }\n    \n    public Flux<OrderResponse> getOrdersBySymbol(String symbol, int page, int size) {\n        return orderRepository.findActiveOrdersBySymbol(symbol)\n                .skip((long) page * size)\n                .take(size)\n                .map(orderMapper::toResponse)\n                .subscribeOn(Schedulers.boundedElastic());\n    }\n    \n    // Internal method for matching engine to fill orders\n    @Transactional\n    public Mono<Order> fillOrder(String orderId, java.math.BigDecimal quantity, java.math.BigDecimal price) {\n        log.debug(\"Filling order: {} with quantity: {}, price: {}\", orderId, quantity, price);\n        \n        return orderRepository.findByOrderId(orderId)\n                .switchIfEmpty(Mono.error(new OrderNotFoundException(orderId)))\n                .doOnNext(order -> order.fill(quantity, price))\n                .flatMap(orderRepository::save)\n                .flatMap(this::publishOrderFill)\n                .doOnSuccess(order -> log.info(\"Order filled: {}, status: {}\", orderId, order.getStatus()));\n    }\n    \n    // Scheduled method to handle order expiration\n    public Flux<Order> processExpiredOrders() {\n        return orderRepository.findExpiredOrders(LocalDateTime.now())\n                .doOnNext(Order::expire)\n                .flatMap(orderRepository::save)\n                .flatMap(this::publishOrderExpiration)\n                .doOnNext(order -> log.info(\"Order expired: {}\", order.getOrderId()));\n    }\n    \n    private Order buildOrderFromRequest(String userId, CreateOrderRequest request) {\n        String orderId = request.getClientOrderId() != null ? \n                request.getClientOrderId() : idGeneratorService.generateOrderId();\n                \n        return Order.builder()\n                .orderId(orderId)\n                .userId(userId)\n                .symbol(request.getSymbol())\n                .side(request.getSide())\n                .type(request.getType())\n                .quantity(request.getQuantity())\n                .price(request.getPrice())\n                .stopPrice(request.getStopPrice())\n                .timeInForce(request.getTimeInForce())\n                .expiresAt(request.getExpiresAt())\n                .status(OrderStatus.PENDING)\n                .createdAt(LocalDateTime.now())\n                .updatedAt(LocalDateTime.now())\n                .build();\n    }\n    \n    private Mono<Order> validateAndSaveOrder(Order order) {\n        return Mono.just(order)\n                .flatMap(this::validateOrderBusinessRules)\n                .flatMap(orderRepository::save)\n                .doOnNext(savedOrder -> savedOrder.setStatus(OrderStatus.OPEN));\n    }\n    \n    private Mono<Order> validateOrderBusinessRules(Order order) {\n        // Add business validation logic here\n        return Mono.just(order);\n    }\n    \n    private Mono<Order> publishOrderToMatchingEngine(Order order) {\n        return matchingEngineService.submitOrder(order)\n                .then(Mono.just(order))\n                .flatMap(this::publishOrderEvent);\n    }\n    \n    private Mono<Order> publishOrderUpdateToMatchingEngine(Order order) {\n        return matchingEngineService.updateOrder(order)\n                .then(Mono.just(order))\n                .flatMap(this::publishOrderEvent);\n    }\n    \n    private Mono<Order> publishOrderCancellationToMatchingEngine(Order order) {\n        return matchingEngineService.cancelOrder(order.getOrderId())\n                .then(Mono.just(order))\n                .flatMap(this::publishOrderEvent);\n    }\n    \n    private Mono<Order> publishOrderFill(Order order) {\n        return publishOrderEvent(order);\n    }\n    \n    private Mono<Order> publishOrderExpiration(Order order) {\n        return publishOrderEvent(order);\n    }\n    \n    private Mono<Order> publishOrderEvent(Order order) {\n        return orderEventPublisher.publishOrderEvent(order)\n                .then(Mono.just(order));\n    }\n    \n    private Mono<Order> findUserOrder(String userId, String orderId) {\n        return orderRepository.findByOrderId(orderId)\n                .filter(order -> order.getUserId().equals(userId))\n                .switchIfEmpty(Mono.error(new OrderNotFoundException(orderId)));\n    }\n    \n    private Mono<Order> validateOrderForUpdate(Order order, UpdateOrderRequest request) {\n        if (!order.isActive()) {\n            return Mono.error(new InvalidOrderStateException(\n                    \"Cannot update order in status: \" + order.getStatus()));\n        }\n        return Mono.just(order);\n    }\n    \n    private Mono<Order> validateOrderForCancellation(Order order) {\n        if (!order.isActive()) {\n            return Mono.error(new InvalidOrderStateException(\n                    \"Cannot cancel order in status: \" + order.getStatus()));\n        }\n        return Mono.just(order);\n    }\n    \n    private Mono<Order> updateOrderFields(Order order, UpdateOrderRequest request) {\n        if (request.getQuantity() != null) {\n            order.setQuantity(request.getQuantity());\n        }\n        if (request.getPrice() != null) {\n            order.setPrice(request.getPrice());\n        }\n        if (request.getStopPrice() != null) {\n            order.setStopPrice(request.getStopPrice());\n        }\n        order.setUpdatedAt(LocalDateTime.now());\n        return Mono.just(order);\n    }\n}